---
id: cf-814C
source: CF
title: An impassioned circulation of affection
author: Neo Wang, Qi Wang, Jesse Choe, Kevin Sheng, Rameez Parwez, Manoj Singh Rawat
---

[Official Editorial (C++)](https://codeforces.com/blog/entry/52449)

## Solution (Two Pointers)

For each query we can keep a sliding window where no more than $m$ letters in
the window are not $c$.

## Implementation

**Time Complexity:** $\mathcal{O}(nq)$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	int garland_len, query_num;
	string garland;
	cin >> garland_len >> garland >> query_num;

	for (int i = 0; i < query_num; i++) {
		int max_repaint;
		char color;
		cin >> max_repaint >> color;

		int l = 0;
		int r = 0;
		int koyomity = 0;
		while (l < garland_len && r < garland_len) {
			while (r < garland_len) {
				if (garland[r] != color) {
					if (max_repaint == 0) break;
					max_repaint--;
				}
				r++;
			}
			koyomity = max(koyomity, r - l);
			max_repaint += garland[l++] != color;
		}
		cout << koyomity << endl;
	}
}
```

</CPPSection>
</LanguageSection>

## Alternative Solution (Two Pointers with Prefix Sums)

For each query we can use prefix sums to check the number of occurrences of a
given letter $c$ and use two pointers to find the maximum Koyomity ending at a
given pointer $p2$ from $0 \dots n$.

## Implementation

**Time Complexity:** $\mathcal{O}(n(k+q))$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAX_N = 1500;

int dp[26][MAX_N + 1];

int main() {
	int garland_len;
	string garland;
	cin >> garland_len >> garland;
	for (int i = 1; i <= garland_len; i++) {
		int color = garland[i - 1] - 'a';
		dp[color][i]++;
	}

	for (int i = 0; i < 26; i++) {
		for (int j = 1; j <= garland_len; j++) { dp[i][j] = dp[i][j - 1] + dp[i][j]; }
	}

	int query_num;
	cin >> query_num;
	for (int i = 0; i < query_num; i++) {
		int max_repaint;
		char color;
		cin >> max_repaint >> color;
		color -= 'a';

		int l = 1, r = 1, koyomity = 1;
		while (r <= garland_len) {
			int c_count = dp[color][r] - dp[color][l - 1] + max_repaint;
			if (c_count < r - l + 1) {
				l++;
			} else {
				koyomity = max(koyomity, r - l + 1);
				r++;
			}
		}
		cout << koyomity << endl;
	}
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

public class Garland {
	private final static int MAX_N = 1500;
	public static void main(String[] args) {
		Kattio io = new Kattio();

		int garlandLen = io.nextInt();
		String garland = io.next();
		int queryNum = io.nextInt();

		int[][] dp = new int[26][MAX_N + 1];
		for (int i = 1; i <= garlandLen; i++) {
			int color = (garland.charAt(i - 1) - 'a');
			dp[color][i]++;
		}

		for (int i = 0; i < 26; i++) {
			for (int j = 1; j <= garlandLen; j++) {
				dp[i][j] = dp[i][j - 1] + dp[i][j];
			}
		}

		for (int i = 0; i < queryNum; i++) {
			int maxRepaint = io.nextInt();
			int color = (io.next().charAt(0) - 'a');

			int l = 1;
			int r = 1;
			int koyomity = 1;
			while (r <= garlandLen) {
				int cCount = dp[color][r] - dp[color][l - 1] + maxRepaint;
				if (cCount < r - l + 1) {
					l++;
				} else {
					koyomity = Math.max(koyomity, r - l + 1);
					r++;
				}
			}
			io.println(koyomity);
		}

		io.close();
	}

	// CodeSnip{Kattio}
}
```

</JavaSection>
</LanguageSection>

## Alternative Solution (Precomputation with Sliding Window and DP)

<Warning>

Dynamic programming is a [Gold](/gold/intro-dp) topic.

</Warning>

This approach solves the problem by precomputing the answers for all possible queries. The problem asks for the length of the longest possible contiguous substring of a single character c, given that you can change at most m other characters in the original string s. The code calculates these answers for every character from 'a' to 'z' and for every possible number of changes m from 0 to n, storing them in a 2D array. This allows each of the q subsequent queries to be answered in constant time.

The core logic revolves around a sliding window technique, not on the string itself, but on the indices of characters that need to be changed.

### The computeAll Function

This function is responsible for all the precomputation. It returns a 2D vector, dp, where dp[c-'a'][m] stores the answer for the target character c+'a' and the maximum number of changes m.

The process is performed independently for each of the 26 lowercase English letters. For a given target character c:

+ **Identify Mismatched Characters**: First, the code finds all the positions in the string s that do not contain the character c. The indices of these _mismatched_ characters are stored in a vector called bad. Let k be the total number of such characters.

```cpp
vector<int> bad;
for (int i = 0; i < n; i++)
{
    if (s[i] != c)
    {
        bad.push_back(i);
    }
}
int k = bad.size();
```

+ **Handle the Easy Case (m >= k)**: If the number of allowed changes m is greater than or equal to the total number of mismatched characters k, we can simply change all of them. This would make the entire string consist of only the character c. Therefore, the longest possible substring is the string itself, with length n.

```cpp
for (int m = k; m <= maxM; m++)
{
    dp[c - 'a'][m] = n;
}
```

+ **Sliding Window Over Mismatches (m < k)**: This is the main part of the algorithm. To get the longest substring of c's, we need to pick a contiguous segment of the original string and use our m changes to fix all the mismatched characters within that segment.

The most efficient way to form a long substring is to use our m changes to fix a contiguous block of m mismatched characters from our bad list. The code iterates through all possible windows of size m over the bad vector.

For each window of m bad characters to fix, starting from bad[i] and ending at bad[i+m-1]:

    - The start of our new, long substring (left) is the position right after the previous bad character we didn't fix (bad[i-1]). If i=0, it means we are fixing the first m bad characters, so our substring can start from index 0.

    + The end of our substring (right) is the position right before the next bad character we didn't fix (bad[i+m]). If this window includes the last bad character in the string, our substring can extend to the end of the string (n-1).

The length of this potential substring is right - left + 1. The code calculates this for every possible window of m bad characters and takes the maximum length.

```cpp
for (int m = 0; m < k; m++)
{
    int maxLen = 0;
    // ... (Special case for m=0 is handled, but the main logic is here)
    // This loop slides a window of `m` bad characters to fix
    for (int i = 0; i + m - 1 < k; i++)
    {
        // The substring starts after the previous bad character (or from index 0)
        int left = (i == 0) ? 0 : bad[i - 1] + 1;
        // The substring ends before the next bad character (or at index n-1)
        int right = (i + m == k) ? n - 1 : bad[i + m] - 1;
        maxLen = max(maxLen, right - left + 1);
    }
    dp[c - 'a'][m] = maxLen;
}
```
+ **Enforce Monotonicity**: Logically, with more available changes, the length of the longest substring cannot decrease. If you can make a substring of length L with m-1 changes, you can surely make one of at least length L with m changes. This final loop ensures our dp table reflects this property by setting dp[c-'a'][m] to be the maximum of its current value and the value for m-1.

```cpp
for (int m = 1; m <= maxM; m++)
{
    dp[c - 'a'][m] = max(dp[c - 'a'][m], dp[c - 'a'][m - 1]);
}
```

### The solve and main Functions

- The solve function is very simple. After all the hard work in computeAll, it just performs a direct lookup in the dp table to get the precomputed answer.

```cpp
int solve(vector<vector<int>> &dp, int m, char c)
{
    return dp[c - 'a'][m];
}
```

- The main function orchestrates the process. It reads the input string s, calls computeAll once to pre-fill the dp table, and then enters a loop to answer each of the q queries by calling solve.

## Implementation

**Time Complexity:** $\mathcal{O}(n^2k + q)$

<LanguageSection>
<CPPSection>

```cpp
#include "bits/stdc++.h"
using namespace std;

vector<vector<int>> computeAll(string &s, int maxM)
{
    int n = s.size();
    vector<vector<int>> dp(26, vector<int>(maxM + 1, 0));

    for (char c = 'a'; c <= 'z'; c++)
    {
        vector<int> bad;
        for (int i = 0; i < n; i++)
        {
            if (s[i] != c)
            {
                bad.push_back(i);
            }
        }

        int k = bad.size();

        for (int m = k; m <= maxM; m++)
        {
            dp[c - 'a'][m] = n;
        }

        for (int m = 0; m < k; m++)
        {
            int maxLen = 0;

            if (m == 0)
            {
                int currentLen = 0;
                for (int i = 0; i < n; i++)
                {
                    if (s[i] == c)
                    {
                        currentLen++;
                        maxLen = max(maxLen, currentLen);
                    }
                    else
                    {
                        currentLen = 0;
                    }
                }
            }
            else if (m <= k)
            {
                for (int i = 0; i + m - 1 < k; i++)
                {
                    int left = (i == 0) ? 0 : bad[i - 1] + 1;
                    int right = (i + m == k) ? n - 1 : bad[i + m] - 1;
                    maxLen = max(maxLen, right - left + 1);
                }
            }

            dp[c - 'a'][m] = maxLen;
        }

        for (int m = 1; m <= maxM; m++)
        {
            dp[c - 'a'][m] = max(dp[c - 'a'][m], dp[c - 'a'][m - 1]);
        }
    }
    return dp;
}

int solve(vector<vector<int>> &dp, int m, char c)
{
    return dp[c - 'a'][m];
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n = 0;
    cin >> n;

    string s;
    cin >> s;

    vector<vector<int>> dp = computeAll(s, n);

    int q = 1;
    cin >> q;
    while (q--)
    {
        int m;
        cin >> m;
        char c;
        cin >> c;
        cout << solve(dp, m, c) << "\n";
    }
    return 0;
}
```

</CPPSection>
</LanguageSection>
